@using Microsoft.Extensions.Options
@using ZauberCMS.Core.Media.Commands
@using ZauberCMS.Core.Media.Models
@using ZauberCMS.Core.Settings
@using ZauberCMS.Core.Shared.Models
@using ZauberCMS.Core.Shared
@using ZauberCMS.Core.Providers
@implements IAsyncDisposable

@if (ParentFolder != null)
{
    <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Center" Gap="0">
        <RadzenIcon Icon="@ParentFolder.MediaType.GetIcon()" /> @ParentFolder.Name
    </RadzenStack>
}

<div @ref="FileDropContainer" class="file-drop-zone @HoverClass" @ondragenter="OnDragEnter" @ondragleave="OnDragLeave" @ondragover="OnDragEnter">

    <div class="text-center">

            <label for="file-upload" style="cursor: pointer; position: relative; font-weight: 600; text-decoration: underline; padding: 30px 40px;">
                <InputFile OnChange="@OnChange" @ref="InputFile" multiple="@(MaxAllowedFiles > 1 ? "multiple" : null)" />
            </label>

    </div>
    
    
</div>
<RadzenStack Visible="@FilesToUpload.Any()" Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Start" Gap="0" class="image-container">
    @foreach (var media in FilesToUpload)
    {
        <RadzenAlert Icon="@(media.MediaType.GetIcon())" Close=@(o => RemoveMedia(media))>
            @media.Name
        </RadzenAlert>
    }
</RadzenStack>
<RadzenButton Click="@(() => Save())">Save</RadzenButton>
<RadzenButton Click="@(() => Clear())">Clear</RadzenButton>

<RadzenStack Visible="@ErrorMessages.Any()" Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Start" Gap="0" class="error-message-container">
    @foreach (var error in ErrorMessages)
    {
        <RadzenAlert AlertStyle="AlertStyle.Danger" Variant="Variant.Flat" Shade="Shade.Lighter">
            @error
        </RadzenAlert>
    }
</RadzenStack>

@code {
    [Inject] public IJSRuntime JsRuntime { get; set; } = default!;
    [Inject] public ProviderService ProviderService { get; set; } = default!;
    [Inject] public IOptions<ZauberSettings> Settings { get; set; } = default!;
    [Inject] public NotificationService NotificationService { get; set; } = default!;
    [Inject] public AppState AppState { get; set; } = default!;
    
    [Parameter] public Guid? ParentId { get; set; }
    [Parameter] public Guid? MediaId { get; set; }
    [Parameter] public int MaxAllowedFiles { get; set; } = 30; // Only allow 30 max at a time, should be setting
    [Parameter] public bool OnlyImages { get; set; }
    [Parameter] public IModalService? ModalService { get; set; }
    [Parameter] public EventCallback<List<FileSaveResult>> ValueChanged { get; set; }
    [Parameter] public EventCallback<List<FileSaveResult>> OnSave { get; set; }
    [Parameter] public List<FileSaveResult> FilesToUpload { get; set; } = [];
    
    private ElementReference FileDropContainer { get; set; }
    private InputFile InputFile { get; set; } = default!;
    private IJSObjectReference? FilePasteModule { get; set; }
    private IJSObjectReference? FilePasteFunctionReference { get; set; }
    private string HoverClass { get; set; } = string.Empty;
    private List<string> ErrorMessages { get; set; } = [];
    private Media? ParentFolder { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        if (ParentId != null)
        {
            var media = await Mediator.Send(new GetMediaCommand { Id = ParentId.Value });
            if (media is { MediaType: MediaType.Folder })
            {
                ParentFolder = media;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            FilePasteModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/filePaste.js");
            FilePasteFunctionReference = await FilePasteModule.InvokeAsync<IJSObjectReference>("initializeFilePaste", FileDropContainer, InputFile.Element);
        }
    }

    void OnDragEnter(DragEventArgs e) => HoverClass = "hover";
    void OnDragLeave(DragEventArgs e) => HoverClass = string.Empty;

    private void RemoveMedia(FileSaveResult media)
    {
        var index = FilesToUpload.FindIndex(c => c.Name == media.Name);
        if (index != -1)
        {
            FilesToUpload.RemoveAt(index);
        }
    }

    private async Task OnChange(InputFileChangeEventArgs e)
    {
        ErrorMessages.Clear();
        
        if ((e.FileCount + FilesToUpload.Count) > MaxAllowedFiles)
        {
            ErrorMessages.Add($"Only {MaxAllowedFiles} files can be uploaded");
            return;
        }

        foreach (var file in e.GetMultipleFiles(MaxAllowedFiles))
        {
            var result = await ProviderService.StorageProvider!.CanUseFile(file, OnlyImages);
            if (result.Success)
            {
                if (MediaId != null)
                {
                    result.CurrentMediaId = MediaId;
                }
                FilesToUpload.Add(result);
            }
            else
            {
                ErrorMessages.AddRange(result.ErrorMessages);
            }
            /*await using var stream = file.OpenReadStream(Settings.Value.MaxUploadFileSizeInBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);*/
            //ImageSources.Add($"data:{file.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}");
        }

        HoverClass = string.Empty;
    }

    private async Task Save()
    {
        if (OnSave.HasDelegate)
        {
            await OnSave.InvokeAsync(FilesToUpload);
        }
        else
        {
            var results = await Mediator.Send(new SaveMediaCommand
            {
                FilesToSave = FilesToUpload,
                ParentFolderId = ParentFolder?.Id
            });

            if (results.Any(x => x.Success == false))
            {
                ErrorMessages.Add("The following files had issues");
                foreach (var errors in results.Where(x => x.Success == false))
                {
                    ErrorMessages.AddRange(errors.ErrorMessages);
                }
            }

            FilesToUpload.Clear();
            if (ValueChanged.HasDelegate)
            {
                await ValueChanged.InvokeAsync(results);
            }
            else
            {
                NotificationService.ShowSuccessNotification($"{results.Count(x => x.Success)} Media Saved");
            }
            await AppState.NotifyMediaChanged();
        }
    }

    private void Clear()
    {
        FilesToUpload.Clear();
    }

    public async ValueTask DisposeAsync()
    {
        if (FilePasteFunctionReference != null)
        {
            await FilePasteFunctionReference.InvokeVoidAsync("dispose");
            await FilePasteFunctionReference.DisposeAsync();
        }

        if (FilePasteModule != null)
        {
            await FilePasteModule.DisposeAsync();
        }
    }

}