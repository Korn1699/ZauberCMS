@using Microsoft.Extensions.Options
@using ZauberCMS.Core.Media.Commands
@using ZauberCMS.Core.Media.Models
@using ZauberCMS.Core.Settings
@using ZauberCMS.Core.Shared.Models
@using ZauberCMS.Core.Providers
@implements IAsyncDisposable

@if (ParentFolder is { MediaType: MediaType.Folder })
{
    <p>Uploading into @ParentFolder.Name</p>
}
<div @ref="FileDropContainer" class="file-drop-zone @HoverClass" @ondragenter="OnDragEnter" @ondragleave="OnDragLeave" @ondragover="OnDragEnter">
    <InputFile OnChange="@OnChange" @ref="InputFile" multiple />
</div>
<RadzenButton Click="@(() => Upload())">Upload</RadzenButton>
<RadzenButton Click="@(() => Clear())">Clear</RadzenButton>

<div class="error-message-container">
    @foreach (var error in ErrorMessages)
    {
        <p>@error</p>   
    }
</div>
<div class="image-container">
    @foreach(var media in FilesToUpload)
    {
        //TODO - Need to show icons or the actual image with remove button
        @media.Name
    }
</div>

@code {
    [Inject] public IJSRuntime JsRuntime { get; set; } = default!;
    [Inject] public ProviderService ProviderService { get; set; } = default!;
    [Inject] public IOptions<ZauberSettings> Settings { get; set; } = default!;
    
    [Parameter] public Media? ParentFolder { get; set; }
    [Parameter] public int MaxAllowedFiles { get; set; } = 30; // Only allow 30 max at a time, should be setting
    [Parameter] public bool OnlyImages { get; set; }
    [Parameter] public IModalService? ModalService { get; set; }
    
    private ElementReference FileDropContainer { get; set; }
    private InputFile InputFile { get; set; } = default!;
    private IJSObjectReference? FilePasteModule { get; set; }
    private IJSObjectReference? FilePasteFunctionReference { get; set; }
    private string HoverClass { get; set; } = string.Empty;
    private List<FileSaveResult> FilesToUpload { get; set; } = [];
    private List<string> ErrorMessages { get; set; } = [];

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            FilePasteModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/filePaste.js");
            FilePasteFunctionReference = await FilePasteModule.InvokeAsync<IJSObjectReference>("initializeFilePaste", FileDropContainer, InputFile.Element);
        }
    }

    void OnDragEnter(DragEventArgs e) => HoverClass = "hover";
    void OnDragLeave(DragEventArgs e) => HoverClass = string.Empty;

    private async Task OnChange(InputFileChangeEventArgs e)
    {
        ErrorMessages.Clear();
        if (e.FileCount > MaxAllowedFiles)
        {
            ErrorMessages.Add($"Only {MaxAllowedFiles} files can be uploaded");
            return;
        }

        foreach (var file in e.GetMultipleFiles(MaxAllowedFiles))
        {
            var result = await ProviderService.StorageProvider!.CanUseFile(file, OnlyImages);
            if (result.Success)
            {
                FilesToUpload.Add(result);
            }
            else
            {
                ErrorMessages.AddRange(result.ErrorMessages);
            }
            /*await using var stream = file.OpenReadStream(Settings.Value.MaxUploadFileSizeInBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);*/
            //ImageSources.Add($"data:{file.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}");
        }

        HoverClass = string.Empty;
    }

    private async Task Upload()
    {
        var results = await Mediator.Send(new SaveMediaCommand
        {
            FilesToSave = FilesToUpload
        });
        
        if (results.Any(x => x.Success == false))
        {
            ErrorMessages.Add("The follow files had issues");
            foreach (var errors in results.Where(x => x.Success == false))
            {
                ErrorMessages.AddRange(errors.ErrorMessages);
            }
        }
        //TODO - Need to show success message?
        FilesToUpload.Clear();
    }
    
    private void Clear()
    {
        FilesToUpload.Clear();
    }

    public async ValueTask DisposeAsync()
    {
        if (FilePasteFunctionReference != null)
        {
            await FilePasteFunctionReference.InvokeVoidAsync("dispose");
            await FilePasteFunctionReference.DisposeAsync();
        }

        if (FilePasteModule != null)
        {
            await FilePasteModule.DisposeAsync();
        }
    }
}